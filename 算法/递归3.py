# 动态规划, 递归问题
# 找到从(x,y)到(0,0)的所有路径
# 只能向x-, y-方向前进
# (x,y)出发点
# +---->---+---->---+-......-+
# |        |        |        |
# V        V        V        V
# +---->---+---->---+-......-+
# |        |        |        |
# V        V        V        V
# +---->---+---->---+-......-+
# ......
# +---->---+---->---+-......-+ (0,0)目标点

def route(x,y):
    # 如果出发点就是目标点(0,0), 可以直接到达。 路径就是 [(0,0)]
    if x==0 and y==0:
        # 路径是一个坐标数组，要用[]扩起来
        path = [(0,0)]
        # route函数返回值是多条路径构成的数组，虽然在函数中只返回了一个路径，但是也要用[]扩起来
        # route函数返回的总是一个二维数组！！！ （每个元素是一个路径，路径是一个坐标数组）
        return [path]
    else:
        # 下面是需要递归的逻辑
        # 要返回的全部子路径初始化为空
        subRoutes = []
        
        # 如果出发点不在最右侧，则将右边点的所有路径添加到子路径中
        # 这里的+号是列表的拼接操作，将两个列表拼接成一个新的列表
        if x>0:
            subRoutes += route(x-1,y)
        # 如果不是最下列，则向下走
        # 如果出发点不在最下面，则将下边点的所有路径添加到子路径中
        if y>0:
            subRoutes += route(x,y-1)
        
        # 遍历所有子路径，添加上当前点(x,y)，然后添加到返回值中
        for i in range(len(subRoutes)):
            subRoutes[i] = [(x,y)] + subRoutes[i]
        
        return subRoutes


while True:
    x,y = map(int,input("X Y = ").split())
    r = route(x,y)
    print(f"总共 {len(r)} 条路径")
    # 打印，方法一, 直接打印二维数组
    print("打印，方法一, 直接打印二维数组")
    print(r)
    # 打印，方法二, 用循环逐一打印每一路径
    print("打印，方法二, 用循环逐一打印每一路径")
    for path in r:
        print(path)
